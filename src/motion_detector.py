#!/usr/bin/env python

import message_filters
import rospy
import cv2
import numpy as np
from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import Image
from geometry_msgs.msg import Point
import math
import time
import classes as cl
import tf
import copy
from std_msgs.msg import UInt16

class Motion:
    def __init__(self):
        global start
        start = 0
        #step1: initialize node, publishers, subscribers
        rospy.init_node("motion_detector_node")
        self.bridge = CvBridge()
        self.pub0 = rospy.Publisher('camera/homography_image_hong', Image, queue_size=2)
        self.pub1 = rospy.Publisher('camera/homography_image_kong', Image, queue_size=2)
        self.pub7 = rospy.Publisher('camera/paper_filter_hong', Image, queue_size=2)
        self.pub8 = rospy.Publisher('camera/paper_filter_kong', Image, queue_size=2)
        self.pub9 = rospy.Publisher('camera/img_warp_hong', Image, queue_size=2)
        self.pub10 = rospy.Publisher('camera/img_warp_kong', Image, queue_size=2)
        self.pub11 = rospy.Publisher('camera/mid_point_image', Image, queue_size=2)

        self.pub2 = rospy.Publisher('camera/visible/image2', Image, queue_size=2)
        self.pub3 = rospy.Publisher('cornerMatch/vertexG',Point, queue_size=2)
        self.pub4 = rospy.Publisher('cornerMatch/vertexW',Point, queue_size=2)

        self.pub5 = rospy.Publisher('cornerMatch/MidPoint',Point, queue_size=2)
        self.sub1 = rospy.Subscriber("usb_cam_k/image_raw", Image, self.imageCallback2)

        self.br = tf.TransformBroadcaster()
        self.MidPoint = None

        #step2: get the paper's position (main class: GetTrans_new)
        pts_src = [[0, 0], [290, 0], [0, 290]] #could be generated by class Predictor
        # pts_src = [[-145, -145], [145, -145], [145, 145],[-145,145]] #could be generated by class Predictor
        # pts_src = pts_src[::-1]
        # pts_src = [[0, 0], [290,0], [290, 290], [0, 290]]
        A = np.matrix([[728.5918150035031, 0, 313.8010207718427], [0, 722.9607586019252, 238.6542554075555], [0, 0, 1]])
        self.motion_detector1 = cl.GetTrans_new(pts_src,A)
        self.motion_detector3 = cl.CornerMatch_v3()
        # self.sub2 = rospy.Subscriber("usb_cam_h/image_raw", Image, self.imageCallback1)
        self.sub3 = rospy.Subscriber("usb_cam_h/image_raw", Image, self.imageCallback3)


        self.sub7 = rospy.Subscriber("cornerMatch/startOpticalFlow", UInt16,self.imageCallback7)
        self.pub6 = rospy.Publisher('camera/visible/opticalFlow', Image, queue_size=2)
        self.sub6 = rospy.Subscriber("usb_cam_k/image_raw", Image,self.imageCallback6)     
        

        self.bridge = CvBridge()
        self.motion_detector6 = cl.optical_flow()
        self.tip_mask = None
        rospy.spin()

    def imageCallback1(self,image):
        #broadcast the position of paper
        cv_image = self.bridge.imgmsg_to_cv2(image, "bgr8")
        clean_image = copy.deepcopy(cv_image)
        _,(Rotation, Translation), frame, filter_frame, img_warp=self.motion_detector1.detect_new(clean_image,view='top')

        #publish the images  
        if frame is not None:
            frame_pub = self.bridge.cv2_to_imgmsg(frame)
            self.pub0.publish(frame_pub)
        if filter_frame is not None:
            filter_pub = self.bridge.cv2_to_imgmsg(filter_frame)
            self.pub7.publish(filter_pub)
        if img_warp is not None:
            warp_pub = self.bridge.cv2_to_imgmsg(img_warp)
            self.pub9.publish(warp_pub)

        clean_image0 = copy.deepcopy(cv_image)
        # tvecs=self.motion_detector1.detect_pnp(clean_image0,3)
        T = copy.deepcopy(Translation)
        # T = copy.deepcopy(tvecs)
        R = copy.deepcopy(Rotation)
        if T is not None:
            T = np.array(T)/1000
            real_height = T[2]
            error = abs(T[2])-real_height
            if abs(error)<0.1:
                if T[2] > 0:
                    trans_T = [T[0],T[1],T[2]]
                else:
                    T = -1*T
                    trans_T = [T[0],T[1],T[2]]
                # print 'T',trans_T 
                if abs(T[2]) <= 1:
                    quaternion = tf.transformations.quaternion_from_euler(R[0], R[1], R[2], axes='sxyz')
                    self.br.sendTransform(trans_T,quaternion,rospy.Time.now(),"paper","usb_cam1")

    def imageCallback2(self, image):
        # if self.motion_detector2:
        cv_image = self.bridge.imgmsg_to_cv2(image, "bgr8")
        clean_image = cv_image.copy()

        result_img3,vertex_w,vertex_g,tip_mask = self.motion_detector3.GetEdges(clean_image)

        self.tip_mask = tip_mask
        image3 = self.bridge.cv2_to_imgmsg(result_img3)
        self.pub2.publish(image3)

        # if vertex_g is not None:
        #     vertexG = Point()
        #     vertexG.x = vertex_g[0]
        #     vertexG.y = vertex_g[1]
        #     vertexG.z = -1
        #     self.pub3.publish(vertexG)
        # else:
        #     vertexG = Point()
        #     vertexG.x = vertexG.y = vertexG.z =-1
        #     self.pub3.publish(vertexG)
        # if vertex_w is not None:
        #     vertexW = Point()
        #     vertexW.x = vertex_w[0]
        #     vertexW.y = vertex_w[1]
        #     vertexW.z = -1
        #     self.pub4.publish(vertexW)
        # else:
        #     vertexW = Point()
        #     vertexW.x = vertexW.y = vertexW.z = -1
        #     self.pub4.publish(vertexW)


    def imageCallback3(self,image):
        cv_image = self.bridge.imgmsg_to_cv2(image, "bgr8")
        clean_image = cv_image.copy()
        is_blue=self.motion_detector1.detect_blue(clean_image) #if there is blue color, return 1
        #pt1: grasp point, pt2: target point. These pts can be generated by predictor
        pt1 =[0,0]
        pt2 =[145,145]
        mid_point,result_img, homo_img, filter_frame, img_warp = self.motion_detector1.detect_mid_point(clean_image,pt1,pt2,view='side_left')

        #publish images
        if homo_img is not None:
            homo_pub = self.bridge.cv2_to_imgmsg(homo_img)
            self.pub1.publish(homo_pub)
        if filter_frame is not None:
            filter_pub = self.bridge.cv2_to_imgmsg(filter_frame)
            self.pub8.publish(filter_pub)
        if img_warp is not None:
            warp_pub = self.bridge.cv2_to_imgmsg(img_warp)
            self.pub10.publish(warp_pub)

        if mid_point is not None and is_blue==0:
            MidPoint = Point()
            MidPoint.x = mid_point[0]
            MidPoint.y = mid_point[1]
            MidPoint.z = mid_point[2]
            print 'mid point',mid_point
            self.MidPoint = MidPoint
            self.pub5.publish(MidPoint)

            image = self.bridge.cv2_to_imgmsg(result_img)
            self.pub11.publish(image)

        else:
            if self.MidPoint is not None:
                self.pub5.publish(self.MidPoint)

    def imageCallback6(self,image):
        if start > 0:
            print "+++++++test2"
            cv_image = self.bridge.imgmsg_to_cv2(image, "bgr8")
            img,vertex_W=self.motion_detector6.get_optical_flow(cv_image,self.tip_mask) 
            if img is not None:
                image = self.bridge.cv2_to_imgmsg(img)
                self.pub6.publish(image)
                vertexW = Point()
                vertexW.x = vertex_W[0][0]
                vertexW.y = vertex_W[0][1]
                vertexW.z = -1
                self.pub4.publish(vertexW)

    def imageCallback7(self,msg):
        # print "+++++++test1", int(msg.data)
        global start 
        start = int(msg.data)

if __name__ == '__main__':
    detector = Motion()
